
## 语法
用关键字var声明可变属性，val声明只读属性。
属性类型可以省略，编译器会从初始器或访问器getter的返回值中推断出来。初始器（initializer）、访问器 getter 和 setter 都是可选的。
```
// 可变属性
var <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]

// 只读属性
val <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]      
```


## 用关键字var声明可变属性，val声明只读属性
```kotlin
class Attr{
    val person: Person = Person()  // 只读的，不能被赋值
    var person2: Person = Person()

    fun test(){
//        person = Person() // 编译器报错 Val cannot be reassigned
        person2 = Person() // 可变的，可以再次被赋值
    }
}
```


## 属性类型可以省略，编译器会自动推断
```kotlin
class Attr2 {
    val person = Person() // 从初始器推断为Person类型
    
    val person2 
        get() = Person()  // 从访问器getter推断为Person类型
}
```


## 属性值必须要在声明的时候初始化
 如果不想在属性声明的时候初始化，可以延迟初始化
 1. 将属性类型声明为可空类型，并初始化为null
 
 2. 用关键字 lateinit 延迟初始化，要保证在使用对象时对象已经初始化，否则会抛出异常
 如何判断 lateinit 的对象已经初始化？
 通过成员引用判断 lateinit 是否初始化，从Kotlin1.2开始支持
 
 3. 用关键字 by lazy 也表示延迟初始化，不过仍然需要在声明的时候初始化，只是初始化的代码是在对象第一次被调用的时候才会执行，
 后续调用不会再执行，会返回记录的结果
```kotlin
class Attr10 {
    // val person: Person // 编译器报错Property must be initialized or be abstract
    var person2: Person? = null // 将属性类型声明为可空类型，并初始化为null
    lateinit var person3: Person // 用关键字 lateinit 延迟初始化
    val person4 by lazy { Person() } // Person()不会被立即执行

    fun test() {
        person2 = Person()
        person2?.name // 使用可空对象时要用安全调用操作符?.

        person3.name // lateinit的对象还未初始化，抛出异常 kotlin.UninitializedPropertyAccessException: lateinit property person has not been initialized
        person3 = Person()
        if (::person3.isInitialized) { // 通过成员引用判断 lateinit 是否初始化，返回true表示已经初始化

        }

        person4.name // 这时Person()被执行
    }
}
```


## getter和setter
getter和setter可选，声明一个属性默认提供getter和setter。
访问一个属性实际是访问了属性的读访问器getter。
设置一个属性实际是访问了属性的写访问器setter。
```
class Attr20{
    var person = Person() // getter和setter可以省略，使用默认的getter和setter
        get() = field
        set(value) {
            field = value
        }

    var person2// 每次访问属性都会调用getter和setter
        get() = Person()
        set(value) {
            // todo
        }

    val person3
        get() = Person() // 只读属性只能定义getter
}
```

## 幕后属性

## 委托属性