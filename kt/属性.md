
## 语法

```
var <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]
    
var 属性名称：属性类型 = 属性值
    getter
    setter
```
### 用关键字 `val` 声明不可变属性，`var` 声明可变属性
不可变属性初始化后不能被赋值
```
val person: Person = Person()
```
可变属性初始化后可以被赋值
```
var person: Person = Person()
person = Person()
```

### 属性类型可以省略，编译器会自动推断
```
val person = Person() // 自动推断出Person类型
```

### getter和setter可以省略
如果没有自定义getter和setter，会自动生成。
```
    var person = Person()
         get() = field // Redundant getter
         set(value){ // Redundant setter
             field = value
         }
```


## 属性值必须初始化
属性值必须要在声明的时候初始化，或者声明为抽象属性，否则编译器会报错
```
val person: Person // 编译器报错Property must be initialized or be abstract
```

如果不想在声明的时候初始化，怎么办？
 - 声明为可空对象
 - 延迟初始化对象

### 声明为可空对象
```
var person: Person? = null
```

### lateinit 延迟初始化
用关键字 lateinit 表示延迟初始化对象，要保证在使用对象时对象已经初始化，否则会抛出异常
```
lateinit var person: Person
```

如何判断 lateinit 的对象已经初始化？

通过成员引用判断 lateinit 是否初始化，从Kotlin1.2开始支持
```
if(::person.isInitialized){
    // 属性已经初始化后执行
}
```



### by lazy 延迟初始化

用关键字 by lazy 表示对象在第一次被调用的时候才会执行，后续调用只是返回记录的结果 
```
val person by lazy { Person() }
```



## 幕后属性

## 委托属性