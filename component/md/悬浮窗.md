


如何添加悬浮窗?
如何添加悬浮窗权限？
悬浮窗的类型？
悬浮窗的flag？
悬浮窗如何获取焦点？
悬浮窗的层级？
https://juejin.cn/post/6844903992980406280
https://blog.csdn.net/qq_33275597/article/details/78429818



问题汇总：
WindowManager添加的view，在语言变化后，监听onConfigurationChanged设置TextView的文本不起作用？
解决：需要重新移除和添加view？


悬浮窗库：https://github.com/yhaolpz/FloatWindow


## 如何添加悬浮窗？
```
        windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        windowLayoutParams = new WindowManager.LayoutParams();
        windowLayoutParams.width = 300;
        windowLayoutParams.height = 300;
        view = LayoutInflater.from(context).inflate(R.layout.window_layout_test, null);
        windowManager.addView(view, windowLayoutParams);
```

## 悬浮窗的类型？
- TYPE_APPLICATION：
```
权限：无需权限。
层级：仅悬浮在当前activity之上。
注：获取windowManager时context必须是Activity的context。否则会出现Unable to add window -- token null is not valid; is your activity running
```

- TYPE_PHONE
```
权限：android6.0以上包括6.0需要动态申请权限，否则会出现Unable to add window android.view.ViewRootImpl$W@ccf4ab1 -- permission denied for this window type
      android8.0以上包括8.0需要添加系统签名和sharedUserId获取系统权限，否则会出现Unable to add window android.view.ViewRootImpl$W@ce7e0e0 -- permission denied for window type 2002
层级：悬浮在其他应用之上。
```

- TYPE_TOAST。同TYPE_PHONE。android8.0以上包括8.0无法使用。
- TYPE_SYSTEM_OVERLAY。同TYPE_PHONE
- TYPE_SYSTEM_ALERT。同TYPE_PHONE

- TYPE_APPLICATION_OVERLAY
```
权限：android8.0以上包括8.0使用，需要动态申请权限，否则会出现Unable to add window android.view.ViewRootImpl$W@1a98ce9 -- permission denied for window type 2038
        或者添加系统签名和sharedUserId获取系统权限。
```





## 悬浮窗的层级？ http://mouxuejie.com/blog/2020-05-10/window-type-zorder/

- 应用窗口从1-99:
```
        public static final int FIRST_APPLICATION_WINDOW = 1; 
        public static final int TYPE_BASE_APPLICATION   = 1;
        public static final int TYPE_APPLICATION        = 2;
        public static final int LAST_APPLICATION_WINDOW = 99;
```


- 子窗口取值从1000-1999：
```
        public static final int FIRST_SUB_WINDOW = 1000;
        public static final int LAST_SUB_WINDOW = 1999;
```

- 系统窗口取值从2000-2999：
```
        public static final int FIRST_SYSTEM_WINDOW     = 2000;
        public static final int TYPE_PHONE              = FIRST_SYSTEM_WINDOW+2;  // 2002
        public static final int TYPE_TOAST              = FIRST_SYSTEM_WINDOW+5;  // 2005
        public static final int TYPE_SYSTEM_OVERLAY     = FIRST_SYSTEM_WINDOW+6; // 2006
        public static final int TYPE_APPLICATION_OVERLAY = FIRST_SYSTEM_WINDOW + 38; // 2038
        public static final int LAST_SYSTEM_WINDOW      = 2999;
```

- 主序和子序
`WindowState`、`WindowManagerService`、`WindowManagerPolicy`
```
    // 表示主序
    final int mBaseLayer;
    // 表示子序
    final int mSubLayer;

    static final int TYPE_LAYER_MULTIPLIER = 10000;
    static final int TYPE_LAYER_OFFSET = 1000;

    WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,
            WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a,
            int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow,
            PowerManagerWrapper powerManagerWrapper) {
        ...
        // 若当前窗口类型为子窗口
        if (mAttrs.type >= FIRST_SUB_WINDOW && mAttrs.type <= LAST_SUB_WINDOW) {
            // 计算主序：
            mBaseLayer = mPolicy.getWindowLayerLw(parentWindow)
                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
            // 计算子序
            mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type);
            ...
        } else {
            mBaseLayer = mPolicy.getWindowLayerLw(this)
                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
            mSubLayer = 0;
            ...
        }
```



为什么Android10.0 TYPE_APPLICATION_OVERLAY的层级再其他System类型的层级之下？
Android10.0: TYPE_APPLICATION_OVERLAY在其他System类型之下
Android8.0: TYPE_APPLICATION_OVERLAY在其他System类型之上




如果显示和隐藏是用view的Visibility，则后显示的悬浮窗层级比先显示的高。
如果显示和隐藏是用windowManager的添加和移除，则后添加的层级比先添加的高。






## 如何添加悬浮窗权限？
```
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
```
```
    /**
     * 申请悬浮窗权限。
     * Android6.0(包括6.0)以上需要申请悬浮窗权限
     */
    public static void requestSystemAlertWindow(FragmentActivity activity, OnPermissionGrantedListener listener) {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
            if (canDrawOverlays(activity)) {
                if (listener != null) listener.OnPermissionGranted();
            } else {
                Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
                intent.setData(Uri.parse("package:" + activity.getPackageName()));
                activity.startActivityForResult(intent, SYSTEM_ALERT_WINDOW_REQUEST_CODE);
            }
        }
    }

    /**
     * 是否有悬浮窗权限。
     */
    public static boolean canDrawOverlays(FragmentActivity activity) {
        boolean canDrawOverlays = true;
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
            canDrawOverlays = Settings.canDrawOverlays(activity);
        }
        return canDrawOverlays;
    }
```
